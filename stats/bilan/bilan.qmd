---
title: "Bilan statistique de la campagne ma-cantine portant sur l'ann√©e 2023 (travail en cours)"
author:
  - "Quentin Loridant"
  - "Val√©rie Merle"
date: "2023-09-07"
format:
  html:
    embed-resources: true
    code-fold: true
    theme:
      - flatly
    toc: true
    toc-depth: 5
execute:
  warning: false
  cache: false
---

# Introduction

## Contexte

Le bilan statistique annuel de l‚Äôapplication des objectifs d‚Äôapprovisionnement fix√©s √† la restauration collective donne lieu √† un rapport du gouvernement qui est remis au parlement chaque ann√©e.
Celui-ci contient une analyse des donn√©es de la campagne de t√©l√©d√©claration. Le premier bilan est disponible pour la [campagne portant sur les donn√©es 2022](https://1648047458-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MSCF7Mdc8yfeIjMxMZr%2Fuploads%2F6RxGNr0aJ4BPSzFsDQGs%2FBilan%20statistique%20EGAlim_achats2022.pdf?alt=media&token=).

Dans ce document nous cr√©ons et documentons les statistiques n√©cessaires pour la campagne ayant eu lieu sur le premier semestre 2023 et portant sur les donn√©es de l'ann√©e 2023.


```{python import}
# | echo: false
import pandas as pd
import numpy as np
import ast
import datetime
from ydata_profiling import ProfileReport
import psycopg2
import plotly.express as px
import matplotlib.pyplot as plt
from matplotlib import dates as mdates
import locale
import utils

```

<!-- Afin de r√©cup√©rer les donn√©es, il vous faut un TOKEN metabase :
`curl -X POST -H "Content-Type: application/json" -d '{"username": <USERNAME>, "password": <PASSWORD>}' https://ma-cantine-metabase.cleverapps.io/api/session` -->

Les donn√©es sont extraites de la base de donn√©es de ma-cantine. Plusieurs filtres sont appliqu√©s :

1. date : les t√©l√©d√©clarations doivent √™tre comprises dans les dates de campagne: `creation_date BETWEEN XX mars au 30 juin 2023`
2. statut : la t√©l√©d√©claration doit avoir √©t√© valid√©e par son √©diteur. `status="SUBMITTED"`
3. ann√©e 2023 : `year==2023`
4. `teledeclaration.value_total_ht` non vide


Vous pouvez retrouver l'int√©gralit√© du code utilis√© sur la page [github de ma-cantine](https://github.com/betagouv/ma-cantine/tree/staging/stats).

```{python Main}
# | echo: false

tds = {}
cache=False

if not cache:
    td_raw = utils.load_td()
    tds = utils.split_td_into_years(td_raw)
    
    for year in utils.CAMPAGNES.keys():
        # Deleting line terminator substring that could corrupt the backup file
        tds[year]['teledeclaration.other_waste_comments'] = tds[year]['teledeclaration.other_waste_comments'].replace('\r\n', ' ', regex=True).replace('\n', ' ', regex=True)

        # Saving the file 
        tds[year].to_csv(f"export_dataset_stats_campagne_{year}_raw.csv", sep=";", index=False)
 
         # Keeping only the columns we want
        tds[year] = tds[year][utils.COLUMNS_TO_SAVE] 

        tds[year].to_csv(f"export_dataset_stats_campagne_{year}.csv", sep=";", index=False)
        
        # TODO Parser siret comme str
        # TODO YEAR and ID en int et pas float


# Whether we use cache or ot, we re-read the file to have consistency in the dataframe
for year in utils.CAMPAGNES.keys():
    tds[year] = pd.read_csv(f"export_dataset_stats_campagne_{year}.csv", sep=";")

# Application de la strat√©gie historique
for year in utils.CAMPAGNES.keys():
    tds[f"{year}_strat_hist"] = tds[year].dropna(
        how="all",
        subset=utils.APPRO_SIMPLIFIED,
    )

# Application de la strat√©gie Je Ne Sais pas
for year in ['2022', '2023']:
    tds[f"{year}_strat_2"] = tds[year].dropna(
        how="any",
        subset=[
            "teledeclaration.value_total_ht",
            "teledeclaration.value_bio_ht",
        ],
    )

# D√©finition des populations assidus, entrantes et sortantes
td_pop = {}
td_pop['2023'] = list(set(tds['2023_strat_2']['canteen.id'].values.tolist())) 
td_pop['2022'] = list(set(tds['2022_strat_2']['canteen.id'].values.tolist())) 
# T√©l√©declarants pr√©sents dans les siret 2023 mais non 2022
entrants = list(set([item for item in td_pop['2023'] if item not in td_pop['2022']]))

# T√©l√©declarants pr√©sents dans les siret 2022 mais non 2023
sortants = list(set([item for item in td_pop['2022'] if item not in td_pop['2023']]))

# T√©l√©d√©clarants pr√©sents lors des deux campagnes
restants = [item for item in td_pop['2022'] if item in td_pop['2023']]

tds_commun = {}
for year in ['2022_strat_2', '2023_strat_2', '2022_strat_hist', '2023_strat_hist']:
    tds_commun[year] = tds[year][tds[year]["canteen.id"].isin(restants)]
    tds_commun[year] = tds_commun[year].drop_duplicates('canteen.id')
```


## Qualit√© des donn√©es

Avant d'√©tudier les chiffres cl√©s de la t√©l√©d√©claration, nous vous pr√©sentons des informations sur la disponibilit√© des donn√©es. Ces informations sont importantes pour saisir au mieux la port√©e des indicateurs.

### üì∑ Campagne 2022

```{python V√©rification du taux de pr√©sence de la donn√©e repas par an}
# | echo: false
# | output: asis

utils.assert_quality(tds)

utils.display_data_coverage(
    tds,
    sub_columns=utils.APPRO_SIMPLIFIED,
    years=["2022"],
)
```

### üì∑ Campagne 2023

```{python V√©rification du taux de pr√©sence de la donn√©e repas par an}
# | echo: false
# | output: asis

utils.assert_quality(tds)

utils.display_data_coverage(
    tds,
    sub_columns=utils.APPRO_SIMPLIFIED,
    years=["2023"],
)
```

### ‚öñÔ∏è Comparaison isop√©rim√®tre

```{python V√©rification du taux de pr√©sence de la donn√©e repas par an}
# | echo: false
# | output: asis

utils.assert_quality(tds)

utils.display_data_coverage(
    tds_commun,
    sub_columns=utils.APPRO_SIMPLIFIED,
    years=["2022_strat_2", "2023_strat_2"],
)
```

Observons la distribution des valeurs d'achats totaux et des achats bio. Les valeurs √©tant tr√®s diff√©rentes entre les diff√©rents acteurs (de 0‚Ç¨ √† plusieurs millions d'euros d√©clar√©s), nous visualisons le logarithme des achats.

```{python}
# | echo: false

import seaborn as sns

col_achats = [
    "teledeclaration.value_bio_ht",
    "teledeclaration.value_total_ht",
]

year = "2023"
for col in col_achats:
    tds[year][col + "_log"] = np.log10(tds[year][[col]].replace(0, 1))

g = sns.displot(tds[year][["teledeclaration.value_bio_ht_log",
    "teledeclaration.value_total_ht_log"]], kde=True)

# Iterate thorugh each axis
for ax in g.axes.flat:
    ax.set_title('Distribution des valeurs d\'achats en ‚Ç¨ totales et bio', fontsize='large')
    ax.set_ylabel('Nombre de TD', fontsize='large')
    ax.set_xlabel('Valeurs d\'achats en ‚Ç¨ (en log)', fontsize='large')
g
```

Nous observons une loi log-normale pour les deux valeurs d'achats (une variable peut √™tre mod√©lis√©e par une loi log-normale si elle est le r√©sultat de la multiplication d'un grand nombre de petits facteurs ind√©pendants).  

A la vue des ces graphiques, nous prenons une **premi√®re hypoth√®se** : *√©tant possible de r√©aliser une mod√©lisation, nous estimons que la qualit√© globale des donn√©es de ces champs est bonne. Il existe cependant une l√©g√®re sur-d√©claration de valeurs tr√®s faibles (par exemple, nous pouvons nous interroger sur la d√©claration de moins de 100‚Ç¨ d'achats bio).*


## Traitement des valeurs manquantes

Nous avons trait√© de 2 fa√ßons diff√©rentes les valeurs manquantes : **strat√©gie historique** et **strat√©gie Je Ne Sais Pas**.

Ces deux strat√©gies se concentrent sur les cinq champs de la t√©l√©d√©claration simplifi√©e: 

1. `value_bio_ht`
2. `value_total_ht`
3. `value_egalim_others_ht`
4. `value_externality_performance_ht`
5. `value_sustainable_ht`


### Strat√©gie Historique

La **"strat√©gie Historique"** (qui a √©t√© appliqu√©e sur le premier bilan) : nous rempla√ßons les valeurs manquantes par la valeur 0, sauf si les 5 champs d'une m√™me d√©claration sont vides, auquel cas nous ne prenons pas en compte la ligne

#### üì∑ 2022

```{python}
# | output: asis
# | echo : false

# TODO : garder value_total dans le dropna ? On supprime peut-etre qq lignes de trop, ou peut etre pas assez !

achats = {}
for col in utils.APPRO_SIMPLIFIED:
    achats[col.replace('teledeclaration.', '')] = tds["2022_strat_hist"][col].isna().sum()

for year in utils.CAMPAGNES.keys():
    tds[f"{year}_strat_hist"][col_achats] = tds[f"{year}_strat_hist"][col_achats].fillna(0)

df_val_manquantes = pd.DataFrame.from_dict(achats, orient="index").rename(columns={0: "Nombre de valeurs manquantes, rempla√ß√©es par 0"})

print(f'Apr√®s filtrage des lignes dont les 5 champs sont manquants, nous avons gard√© **{len(tds["2022_strat_hist"])}** t√©l√©d√©clarations sur les **{len(tds["2022"])}** t√©l√©d√©clarations totales.\n Ensuite nous avons rempla√ß√© par 0 les valeurs manquantes : \n')
print(df_val_manquantes.to_markdown())
```

#### üì∑ 2023
```{python}
# | output: asis
# | echo : false

achats = {}
for col in utils.APPRO_SIMPLIFIED:
    achats[col.replace('teledeclaration.', '')] = tds["2023_strat_hist"][col].isna().sum()

for year in utils.CAMPAGNES.keys():
    tds[f"{year}_strat_hist"][col_achats] = tds[f"{year}_strat_hist"][col_achats].fillna(0)

df_val_manquantes = pd.DataFrame.from_dict(achats, orient="index").rename(columns={0: "Nombre de valeurs manquantes, rempla√ß√©es par 0"})

print(f'Apr√®s filtrage des lignes dont les 5 champs sont manquants, nous avons gard√© **{len(tds["2023_strat_hist"])}** t√©l√©d√©clarations sur les **{len(tds["2023"])}** t√©l√©d√©clarations totales.\n Ensuite nous avons rempla√ß√© par 0 les valeurs manquantes : \n')
print(df_val_manquantes.to_markdown())
```

#### ‚öñÔ∏è Comparaison isop√©rim√®tre

### Strat√©gie 'Je Ne Sais Pas'

La **"strat√©gie Je Ne Sais Pas"** : afin de minimiser l'impact des valeurs manquantes, nous supprimons toutes les lignes d√®s que le champ `teledeclaration.value_bio_ht` est vide. 

Dans les autres cas, comme dans la strat√©gie 'Historique', nous rempla√ßons les champs vides par 0.


```{python}
# | output: asis
# | echo: false

year = '2023'
print(f'Nous supprimons {len(tds[year]) - len(tds[f"{year}_strat_2"])} lignes car le champ `teledeclaration.value_bio_ht` est vide. \n')
```

# Chiffres cl√©s

## Comparaison des strat√©tiges de valeurs manquantes

### Chiffre g√©n√©raux
```{python Nombre de sites de restauration concern√©s par la t√©l√©d√©claration}
# | echo: false
# | output: asis

indic_divers, indic_appro = utils.calcul_indicateur(tds, years=["2023_strat_2", "2023_strat_hist", "2022_strat_2", "2022_strat_hist"])

indic_divers = indic_divers.rename(columns={'2023_strat_2': 'Donn√©es 2023 - Strat√©gie "Je Ne Sais Pas"', '2023_strat_hist': 'Donn√©es 2023 - Strat√©gie "Historique"'})
indic_divers = utils.ajout_col_comparaison(indic_divers)

utils.display_indicateurs(indic_divers)

```

### Chiffres appro
```{python Nombre de sites de restauration concern√©s par la t√©l√©d√©claration}
# | echo: false
# | output: asis

indic_appro = indic_appro.rename(columns={'2023_strat_2': 'Donn√©es 2023 - Strat√©gie "Je Ne Sais Pas"', '2023_strat_hist': 'Donn√©es 2023 - Strat√©gie "Historique"'})
indic_appro = utils.ajout_col_comparaison(indic_appro)

utils.display_indicateurs(indic_appro)
```

::: {.callout-note}
Pour la suite de l'√©tude, nous utiliserons uniquement la strat√©gie "**Je Ne Sais Pas**"" afin de minimiser les hypoth√®ses que nous prenons sur les donn√©es.
:::

## Comparaison avec l'ann√©e pr√©c√©dente

### Chiffre g√©n√©raux
```{python Nombre de sites de restauration concern√©s par la t√©l√©d√©claration}
# | echo: false
# | output: asis

indic_divers, indic_appro = utils.calcul_indicateur(tds, years=["2022_strat_2", "2023_strat_2"])
indic_divers = utils.ajout_col_comparaison(indic_divers)
indic_divers = indic_divers.rename(columns={'2023_strat_2': 'Donn√©es 2023', '2022_strat_2': 'Donn√©es 2022'})
utils.display_indicateurs(indic_divers)

```

### Chiffres appro
```{python Nombre de sites de restauration concern√©s par la t√©l√©d√©claration}
# | echo: false
# | output: asis
indic_appro = utils.ajout_col_comparaison(indic_appro)
indic_appro = indic_appro.rename(columns={'2023_strat_2': 'Donn√©es 2023', '2022_strat_2': 'Donn√©es 2022'})
utils.display_indicateurs(indic_appro)
```

### Chiffres par famille de produits
::: {.callout-warning}
Pour le moment, ces chiffres ne d√©crivent que les t√©l√©d√©clarations de type simplifi√©es. L'ajout de t√©l√©d√©claration compl√®tes est en cours. A priori, les ratio devraient cependant rester sembables.
:::
```{python Nombre de sites de restauration concern√©s par la t√©l√©d√©claration}
# | echo: false
# | output: asis
indic_famille = utils.calcul_indicateur_famille(tds, years=["2022_strat_2", "2023_strat_2"])
indic_famille = utils.ajout_col_comparaison(indic_famille)
indic_famille = indic_famille.rename(columns={'2023_strat_2': 'Donn√©es 2023', '2022_strat_2': 'Donn√©es 2022'})
utils.display_indicateurs(indic_famille)
```

{{< include _secteurs.qmd >}}
{{< include _populations.qmd >}}