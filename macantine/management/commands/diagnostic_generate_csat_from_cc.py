import logging
import time
from copy import deepcopy

from django.core.management.base import BaseCommand
from django.db.utils import IntegrityError

from api.serializers import CanteenTeledeclarationSerializer
from data.models import Canteen, Diagnostic
from macantine.utils import distribute_appro_values_between_satellites

logger = logging.getLogger(__name__)


class Command(BaseCommand):
    """
    Usage:
    - python manage.py diagnostic_generate_csat_from_cc --year 2024
    - python manage.py diagnostic_generate_csat_from_cc --year 2024 --apply
    """

    help = "Generate diagnostics of CSAT by splitting diagnostics of their central kitchens"

    def add_arguments(self, parser):
        parser.add_argument(
            "--year",
            dest="year",
            type=int,
            required=True,
            help="Year of the teledeclaration campaign to process",
        )
        parser.add_argument(
            "--apply",
            action="store_true",
            help="To apply changes, otherwise just show what would be done (dry run).",
            default=False,
        )

    def handle(self, *args, **options):  # noqa: C901
        year = options["year"]
        apply = options["apply"]
        start_time = time.time()

        logger.info(
            f"Starting task: generate diagnostics for satellite canteens using central kitchen's diagnostics, campaign {year}"
        )

        if not apply:
            logger.info("Dry run mode, no changes will be applied.")

        logger.info("Step 1a: Delete all diagnostics already generated by the script")
        diagnostic_csat_generated_existing_qs = Diagnostic.objects.filter(
            generated_from_central_kitchen_diagnostic=True, year=year
        )
        logger.info(
            f"Found {diagnostic_csat_generated_existing_qs.count()} diagnostics to delete (already generated by the script for the year {year})"
        )
        if apply:
            diagnostic_csat_generated_existing_qs.delete()
            logger.info("They have been deleted")

        logger.info(
            "Step 1b: unarchive all diagnostics of satellites that were previously overriden by a central kitchen diagnostic"
        )
        diagnostic_csat_to_unarchive_qs = Diagnostic.objects.filter(
            status=Diagnostic.DiagnosticStatus.OVERRIDEN_BY_CC, year=year
        )
        logger.info(
            f"Found {diagnostic_csat_to_unarchive_qs.count()} diagnostics to unarchive (overriden by central kitchen for the year {year})"
        )
        if apply:
            diagnostic_csat_to_unarchive_qs.update(status=Diagnostic.DiagnosticStatus.SUBMITTED)
            logger.info("They have been unarchived")

        logger.info(
            "Step 2: Fetch all valid central kitchen diagnostics that have been teledeclared for the given year"
        )
        diagnostics_cc_qs = Diagnostic.objects.teledeclared_for_year(year=year).filter(
            canteen_snapshot__production_type__in=[
                Canteen.ProductionType.CENTRAL,
                Canteen.ProductionType.CENTRAL_SERVING,
            ],
        )
        logger.info(f"Found {diagnostics_cc_qs.count()} diagnostics of central kitchens to process")

        logger.info(
            "Step 3: Loop on the diagnostics of the central kitchens, and generate diagnostics for their satellites"
        )
        for diagnostic in diagnostics_cc_qs:
            diagnostic_type = diagnostic.diagnostic_type
            cc_production_type = diagnostic.canteen_snapshot["production_type"]

            # fields to distribute
            fields = Diagnostic.AGGREGATED_APPRO_FIELDS
            if diagnostic_type == Diagnostic.DiagnosticType.SIMPLE:
                fields += Diagnostic.SIMPLE_APPRO_FIELDS
            else:
                fields += Diagnostic.COMPLETE_APPRO_FIELDS

            # satellites
            satellites = diagnostic.satellites_snapshot
            satellites_len = len(satellites) if satellites else 0
            updated_appro_fields = {}

            if cc_production_type == Canteen.ProductionType.CENTRAL:
                if satellites_len == 0:
                    logger.error(
                        f"Task failed for diagnostic {diagnostic.id} (teledeclaration_id {diagnostic.teledeclaration_id}, production_type {cc_production_type}): Empty satellites"
                    )
                    continue
                updated_appro_fields = distribute_appro_values_between_satellites(diagnostic, fields, satellites_len)
            elif cc_production_type == Canteen.ProductionType.CENTRAL_SERVING:
                satellites_len += 1
                updated_appro_fields = distribute_appro_values_between_satellites(diagnostic, fields, satellites_len)
                # create a diagnostic for the central serving kitchen itself
                create_new_diag_from_cc(
                    diagnostic,
                    diagnostic.canteen_snapshot["id"],
                    fields,
                    updated_appro_fields,
                    central_serving=True,
                    apply=apply,
                )
            else:
                logger.error(
                    f"Task failed: Should only loop over central kitchen diagnostics. Detected a wrong production type: {cc_production_type}"
                )
                return

            if satellites:
                for satellite in satellites:
                    create_new_diag_from_cc(diagnostic, satellite["id"], fields, updated_appro_fields, apply=apply)
                    archive_satellite_diag(satellite["id"], year, apply=apply)

        # Done!
        diagnostic_csat_generated_qs = Diagnostic.objects.filter(
            generated_from_central_kitchen_diagnostic=True, year=year
        )
        logger.info(
            f"Task completed. Generated {diagnostic_csat_generated_qs.count()} diagnostics for {year} in {time.time() - start_time:.2f} seconds"
        )


def create_new_diag_from_cc(diag, canteen_id, fields, updated_appro_fields, central_serving=False, apply=False):
    """
    Create a new diagnostic for a satellite canteen, based on the central kitchen's diagnostic.
    """
    # keep most of the fields identical with the central kitchen's diagnostic
    new_diag = deepcopy(diag)

    # change the id (to create a new object)
    new_diag.pk = None

    # change the canteen FK
    # we fetch the canteen satellite as of the creation date of the diagnostic, for accurate snapshot
    if not central_serving:
        try:
            canteen_asof_date_extraction = Canteen.history.as_of(diag.creation_date).get(pk=canteen_id)
        except Exception:
            try:
                canteen_asof_date_extraction = Canteen.all_objects.get(pk=canteen_id)
            except Canteen.DoesNotExist:
                logger.warning(
                    f"Task warning: The canteen {canteen_id} does not exist anymore, thus the diagnostic cannot be generated"
                )
                return

        new_diag.canteen = canteen_asof_date_extraction

    # change the appro fields
    for field in fields:
        setattr(new_diag, field, updated_appro_fields[field])

    # change other fields: yearly_meal_count ?

    # change the snapshots
    new_diag.satellites_snapshot = None
    new_diag.canteen_snapshot = CanteenTeledeclarationSerializer(new_diag.canteen).data

    # change some metadata fields
    new_diag.creation_source = "generate_csat_diagnostics script"
    new_diag.generated_from_central_kitchen_diagnostic = True

    if apply:
        try:
            new_diag.save()
        except IntegrityError:
            logger.error(
                f"Task error: Cannot save generated diagnostic as it would create a duplicate. Diag Id: {diag.id} / Canteen Id: {canteen_id}"
            )


def archive_satellite_diag(canteen_id, year, apply=False):
    """
    Some satellite canteens may already have a submitted diagnostic for the given year.
    How come? If they had teledeclared individually before being linked to the central kitchen.
    We need to archive these diagnostics, as they are now overriden by the one generated from their central kitchen's diagnostic.
    """
    diag_to_archive = (
        Diagnostic.objects.teledeclared()
        .filter(canteen__id=canteen_id, year=year, generated_from_central_kitchen_diagnostic=False)
        .first()
    )
    if diag_to_archive:
        if apply:
            diag_to_archive.status = Diagnostic.DiagnosticStatus.OVERRIDEN_BY_CC
            diag_to_archive.save()
